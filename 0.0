SELECT t1.tran_term
FROM ucdb_chnseg_sbx.G76083_chnseg_atm_202512ff t1
WHERE NOT EXISTS (
    SELECT 1
    FROM ucdb_chnseg_sbx.AD44238_chnseg_atm_202512ff t2
    WHERE t1.tran_term = t2.tran_term
);

/* Get rows in Table 1 that are NOT exactly the same in Table 2 */
SELECT tran_term, iss_bank_num 
FROM ucdb_chnseg_sbx.G76083_chnseg_atm_202512ff
MINUS
SELECT tran_term, iss_bank_num 
FROM ucdb_chnseg_sbx.AD44238_chnseg_atm_202512ff;







Phase 1: Calculation & Initial Storage
1. Operation (Data Generation): The script generates a DataFrame of all calendar dates (date_df) and reads valid effective dates from the source (cif.cif_a2c_info).
2. Operation (Logic): It performs a Cross Join between these two sets, calculates the date difference, and filters for the minimum difference (Nearest Neighbor logic).
3. TABLE CREATED: The result is written to a sandbox table.
• Table: ucdb_chnseg_sbx.DY_datemap_3
• Action: saveAsTable
Phase 2: Staging for Production
1. TABLE CREATED: The same result is written to a temporary "staging" table in the production schema.
• Table: rabp.AD44238_chnseg_a2c_date_map_temp
• Action: saveAsTable
Phase 3: The First Swap (Go Live)
1. TABLE DROPPED: The existing production table is removed to make space.
• Table: rabp.AD44238_chnseg_a2c_date_map
• Action: DROP TABLE IF EXISTS
2. TABLE ALTERED: The temporary table is renamed to become the production table.
• Table: rabp.AD44238_chnseg_a2c_date_map_temp → rabp.AD44238_chnseg_a2c_date_map
• Action: ALTER TABLE ... RENAME TO ...
Phase 4: Optimization (Sorting)
1. Operation (Sort): The script reads the new production table and orders the data by date (orderBy("date")).
2. TABLE CREATED: The sorted data is saved to a backup table.
• Table: rabp.AD44238_chnseg_a2c_date_map_b
• Action: saveAsTable
Phase 5: Final Commit
1. TABLE DROPPED: The production table is dropped again.
• Table: rabp.AD44238_chnseg_a2c_date_map
• Action: DROP TABLE
2. TABLE CREATED: The final, sorted table is recreated from the backup.
• Table: rabp.AD44238_chnseg_a2c_date_map
• Action: saveAsTable (from _b table)





0.1



Sequential Process Flow (Script 2)
Phase 1: Calculation & Monthly Backup
1. Operation (Data Generation): The script generates a calendar for a specific month (e.g., Nov 2025) and finds valid effective dates from cif.cif_cstmr_mstr.
2. Operation (Logic): It runs the "Nearest Neighbor" logic (Cross Join + Min Diff) to map dates for that specific month.
3. TABLE CREATED: The result is saved to a sandbox table.
• Table: ucdb_chnseg_sbx.DY_datemap_3b
• Action: saveAsTable
4. TABLE CREATED: The result is also saved to a monthly backup table.
• Table: rabp.AD44238_chnseg_cif_mstr_date_map_202511 (Variable name table_name_month)
• Action: saveAsTable
Phase 2: The Merge (Union with History)
1. Operation (Union): The script reads the current production table (history) and combines it with the new monthly table using UNION.
2. TABLE CREATED: The combined dataset (Old + New) is written to a temporary staging table.
• Table: rabp.AD44238_chnseg_cif_mstr_date_map_temp
• Action: saveAsTable
Phase 3: The Swap (Go Live)
1. TABLE DROPPED: The existing production table is removed to make space.
• Table: rabp.AD44238_chnseg_cif_mstr_date_map
• Action: DROP TABLE IF EXISTS
2. TABLE ALTERED: The temporary table is renamed to become the new production table.
• Table: rabp.AD44238_chnseg_cif_mstr_date_map_temp → rabp.AD44238_chnseg_cif_mstr_date_map
• Action: ALTER TABLE ... RENAME TO ...





1

Phase 1: Extract Raw Transactions (Table A)
• Input: Source Transaction Table (tas.tas_jrnlmstr...) & Script 1 Output (A2C Date Map).
• Action: The script pulls raw ATM transactions (filtered for Merchant Code '6011') and links them to accounts using the A2C map.
• Table Operation: CREATE / OVERWRITE
• Table: ucdb_chnseg_sbx.ATM_data_sbx_202511 (Variable table_name_a)
• Note: The explicit DROP TABLE command is commented out; the script relies on mode("overwrite").
Phase 2: Build the Date Map (Table B)
• Input: Table A (Raw Data) & Script 2 Output (CIF Master Date Map).
• Action: It extracts unique transaction dates from the raw data and finds the matching "effective date" for the customer profile.
• Table Operation: CREATE / OVERWRITE
• Table: ucdb_chnseg_sbx.ATM_data_sbx_202511_datelist (Variable table_name_b)
Phase 3: Enrich with Customer Data (Table C)
• Input: Table B (Date List) & Customer Master (cif.cif_cstmr_mstr).
• Action: It uses the dates from Table B to look up specific customer details (Household ID, Segment, Client Type) from the master table.
• Table Operation: CREATE / OVERWRITE
• Table: ucdb_chnseg_sbx.ATM_data_sbx_202511_cif (Variable table_name_c)
Phase 4: Final Assembly (Table D)
• Input: Table A (Raw Transactions) & Table C (Customer Info).
• Action: It joins the raw transactions with the enriched customer details to create the final dataset.
• Table Operation: CREATE / OVERWRITE
• Table: ucdb_chnseg_sbx.ATM_data_sbx_202511_f (Variable table_name_d)





3

1. The Data Sources
The script pulls raw data from two specific tables in the aws_connect_rtl schema:
1. aws_connect_rtl.AWS_RTL_CONTACTTRACERECORDS: The master log of all calls (Time, Contact ID, Queue).
2. aws_connect_rtl.aws_rtl_contacttracerecords_attributes: A detailed table containing "Tags" attached to calls (like Line of Business, App Name, etc.).
2. Sequential Process Flow (Step-by-Step)
This script executes in 4 distinct phases. The explicit DROP commands are commented out, so the script relies on Spark's Overwrite Mode to clear out old data automatically.
Phase 1: Extract & Pivot Attributes (Table B)
• Goal: Create a clean staging table of calls with their specific tags attached.
• Action:
1. Reads the master call log and filters for INBOUND voice calls.
2. Queries the Attributes Table three separate times to find:
• LOB (Line of Business)
• IVR_App (Application Name)
• CIF_Static_Key (Customer Link)
3. Joins these attributes back to the master call log.
• Table Operation: CREATE / OVERWRITE
• Table: ucdb_chnseg_sbx.AWSIVR_202511b (Variable: table_name_b)
Phase 2: Build the Date Map (Table DateList)
• Goal: Figure out the "Effective Date" for every call.
• Action: It extracts unique call timestamps from Table B and joins them with the Script 2 Output (CIF Master Date Map) to find which customer profile version applies to that specific call time.
• Table Operation: CREATE / OVERWRITE
• Table: ucdb_chnseg_sbx.AWSIVR_202511_datelist (Variable: _datelist)
Phase 3: Enrich with Customer Data (Table CIF)
• Goal: Get the customer demographics (Household ID, Segment, etc.).
• Action: It uses the dates from the DateList table to query the main Customer Master table (cif.cif_cstmr_mstr).
• Table Operation: CREATE / OVERWRITE
• Table: ucdb_chnseg_sbx.AWSIVR_202511_cif (Variable: _cif)
Phase 4: Final Assembly (Table F)
• Goal: Combine the calls with the customer data.
• Action: It joins the Staged Call Data (Table B) with the Customer Info (Table CIF) to produce the final dataset.
• Table Operation: CREATE / OVERWRITE
• Table: ucdb_chnseg_sbx.AWSIVR_202511f (Variable: _f)




external source tables

1. CIF Schema (Customer Information)
• cif.cif_a2c_info
• Used in: Script 1 (A2C Date Map), Script 3 (ATM)
• cif.cif_cstmr_mstr
• Used in: Script 2 (CIF Date Map), Script 3 (ATM), Script 5 (AWS IVR)
2. TAS Schema (Transactions)
• tas.tas_jrnlmstr_trnsct_vw
• Used in: Script 3 (ATM Transactions)
3. AWS Connect RTL Schema (Call Center)
• aws_connect_rtl.AWS_RTL_CONTACTTRACERECORDS
• Used in: Script 5 (AWS IVR)
• aws_connect_rtl.aws_rtl_contacttracerecords_attributes
• Used in: Script 5 (AWS IVR)



Final Active Tables


Script 1: A2C Date Map
• rabp.AD44238_chnseg_a2c_date_map (Final Production Table)
• rabp.AD44238_chnseg_a2c_date_map_b (Sorted Backup)
• ucdb_chnseg_sbx.DY_datemap_3 (Sandbox Trace)
Script 2: CIF Master Date Map
• rabp.AD44238_chnseg_cif_mstr_date_map (Final Production Table)
• rabp.AD44238_chnseg_cif_mstr_date_map_202511 (Monthly Backup)
• ucdb_chnseg_sbx.DY_datemap_3b (Sandbox Trace)
Script 3: ATM Transactions
(Note: No tables are dropped, so all remain)
• ucdb_chnseg_sbx.ATM_data_sbx_202511_f (Final Output)
• ucdb_chnseg_sbx.ATM_data_sbx_202511_cif (Customer Helper)
• ucdb_chnseg_sbx.ATM_data_sbx_202511_datelist (Date Helper)
• ucdb_chnseg_sbx.ATM_data_sbx_202511 (Raw Data)
Script 5: AWS IVR Data
(Note: No tables are dropped, so all remain)
• ucdb_chnseg_sbx.AWSIVR_202511f (Final Output)
• ucdb_chnseg_sbx.AWSIVR_202511_cif (Customer Helper)
• ucdb_chnseg_sbx.AWSIVR_202511_datelist (Date Helper)
• ucdb_chnseg_sbx.AWSIVR_202511b (Staging Data)





INSERT INTO TABLE ucdb_rsbb_mdl_sbx.ccea_tcc_call_reasons 
VALUES (
  '827abd2b-9f05-49e9-8136-21ee0fb87ebc',
  '0181e720-c68e-4607-8999-10a0a8da0c65',
  '2026-01-10',
  '51749743',
  'AGENT-Hello, thank you for calling...',
  2,
  'Payments',
  20260110,
  20260110
);




INSERT INTO TABLE ucdb_tcc_mdl_sbx.ccea_cplt_pred_calls 
VALUES (
  '827abd2b-9f05-49e9-8136-21ee0fb87ebc',
  '0181e720-c68e-4607-8999-10a0a8da0c65',
  '2026-01-10 16:28:57',
  '51749743',
  'AGENT-Hello, thank you for calling...',
  1,
  0.2814375,
  'Tier 1',
  0.0646961,
  'Phone Channel - About TCC Only',
  0.3863011,
  20260110,
  20260110
);












script 8(10th file)



Script 8: Household CIN Profile (Channel Segmentation)
• (Cell 23) After performing a cross-join between distinct Customer Keys (CIF) and the Week Calendar to create a base timeline, the table rabp.AD44238_CHNSEG_CIN_WEEK_{output_file_date} is CREATED (Overwrite Mode).
• (Cell 26) After joining the base timeline with raw interaction data to sum transaction counts (Teller, Agent, ATM, Mobile, etc.) by week, the table rabp.AD44238_CHNSEG_CIN_W_ACT_{output_file_date} is CREATED (Overwrite Mode).
• (Cell 28) After aggregating the weekly interaction counts up to the Monthly level (grouping by month_seq), the table rabp.AD44238_CHNSEG_CIN_M_ACT_{output_file_date} is CREATED (Overwrite Mode).
• (Cell 30) After aggregating the interaction counts up to the Quarterly level (grouping by quarter_seq), the table rabp.AD44238_CHNSEG_CIN_Q_ACT_{output_file_date} is CREATED (Overwrite Mode).
• (Cell 32) After aggregating the interaction counts up to the Semi-Annual level (grouping by semiannual_seq), the table rabp.AD44238_CHNSEG_CIN_S_ACT_{output_file_date} is CREATED (Overwrite Mode).
• (Cell 34) After aggregating the interaction counts up to the Yearly level to get total annual volumes per customer, the table rabp.AD44238_CHNSEG_CIN_Y_ACT_{output_file_date} is CREATED (Overwrite Mode).
• (Cell 44) After applying logic to categorize each channel (Agent, TCC, Digital, etc.) into frequency buckets (e.g., '01.Never', '05.Monthly', '06.Weekly'), the classification table rabp.AD44238_CHNSEG_CIN_CTG_{output_file_date} is CREATED (Overwrite Mode).
• (Cell 53) After applying complex preference logic to determine specific segments (e.g., "Multi-Channel (Non-Branch)" vs. "Digital Only") based on frequency combinations, the table rabp.AD44238_CHNSEG_CIN_CTG_6_{output_file_date} is CREATED (Overwrite Mode).
• (Cell 58) After refining the segment flags and filtering for the final required columns, the staging table rabp.AD44238_CHNSEG_CIN_CTG_F_{output_file_date} is CREATED (Overwrite Mode).
• (Cell 60) After joining the computed Channel Segments with the main Customer Demographics (City, State, Tenure, Generation), the final output table {output_file_name} is CREATED (Overwrite Mode).
• (Cell 63) After selecting all records from the final output to create a standalone "Current" snapshot for immediate usage, the table rabp.AD44238_CHNSEG_CIN_CURR is CREATED (Overwrite Mode).
